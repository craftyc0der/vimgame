use macroquad::input::KeyCode;

#[derive(Debug, PartialEq, Eq, Clone, Hash)]
pub enum VimCommand {
    MoveLeft,
    MoveDown,
    MoveUp,
    MoveRight,
    MoveWordForward,
    MoveWordBack,
    MoveWordEnd,
    MoveLineStart,
    MoveLineEnd,
    MoveScreenTop,
    MoveScreenMiddle,
    MoveScreenBottom,
    MoveParagraphForward,
    MoveParagraphBack,
    InsertMode,
    Escape,
    None,
    // New commands for Levels 11-20
    StartFindNext,       // f
    StartFindPrev,       // F
    StartTillNext,       // t
    StartTillPrev,       // T
    RepeatFind,          // ;
    RepeatFindReverse,   // ,
    StartSearchForward,  // /
    StartSearchBackward, // ?
    NextMatch,           // n
    PrevMatch,           // N
    DeleteChar,          // x
    // Completed commands (generated by GameState)
    FindNextChar(char),
    FindPrevChar(char),
    TillNextChar(char),
    TillPrevChar(char),
    SearchForward(String),
    SearchBackward(String),
}

pub struct InputHandler {
    // State for multi-key commands could go here
}

impl InputHandler {
    pub fn new() -> Self {
        Self {}
    }

    pub fn map_key(&mut self, key: KeyCode, shift: bool) -> VimCommand {
        match key {
            KeyCode::H => {
                if shift {
                    VimCommand::MoveScreenTop
                } else {
                    VimCommand::MoveLeft
                }
            }
            KeyCode::J => VimCommand::MoveDown,
            KeyCode::K => VimCommand::MoveUp,
            KeyCode::L => {
                if shift {
                    VimCommand::MoveScreenBottom
                } else {
                    VimCommand::MoveRight
                }
            }
            KeyCode::M => {
                if shift {
                    VimCommand::MoveScreenMiddle
                } else {
                    VimCommand::None
                }
            }
            KeyCode::W => VimCommand::MoveWordForward,
            KeyCode::B => VimCommand::MoveWordBack,
            KeyCode::E => VimCommand::MoveWordEnd,
            KeyCode::Key0 => VimCommand::MoveLineStart,
            KeyCode::Key4 => {
                if shift {
                    VimCommand::MoveLineEnd
                } else {
                    VimCommand::None
                }
            } // $ is Shift+4
            KeyCode::RightBracket => {
                if shift {
                    VimCommand::MoveParagraphForward
                } else {
                    VimCommand::None
                }
            } // } is Shift+]
            KeyCode::LeftBracket => {
                if shift {
                    VimCommand::MoveParagraphBack
                } else {
                    VimCommand::None
                }
            } // { is Shift+[
            KeyCode::I => VimCommand::InsertMode,
            KeyCode::Escape => VimCommand::Escape,
            KeyCode::F => {
                if shift {
                    VimCommand::StartFindPrev
                } else {
                    VimCommand::StartFindNext
                }
            }
            KeyCode::T => {
                if shift {
                    VimCommand::StartTillPrev
                } else {
                    VimCommand::StartTillNext
                }
            }
            KeyCode::Semicolon => VimCommand::RepeatFind,
            KeyCode::Comma => VimCommand::RepeatFindReverse,
            KeyCode::Slash => {
                if shift {
                    VimCommand::StartSearchBackward
                } else {
                    VimCommand::StartSearchForward
                }
            }
            KeyCode::N => {
                if shift {
                    VimCommand::PrevMatch
                } else {
                    VimCommand::NextMatch
                }
            }
            KeyCode::X => VimCommand::DeleteChar,
            _ => VimCommand::None,
        }
    }

    // Helper to convert char to command if we process chars instead of KeyCodes
    pub fn map_char(&mut self, c: char) -> VimCommand {
        match c {
            'h' => VimCommand::MoveLeft,
            'j' => VimCommand::MoveDown,
            'k' => VimCommand::MoveUp,
            'l' => VimCommand::MoveRight,
            'w' => VimCommand::MoveWordForward,
            'b' => VimCommand::MoveWordBack,
            'e' => VimCommand::MoveWordEnd,
            'i' => VimCommand::InsertMode,
            // Escape is usually not a char in this context, handled by KeyCode
            _ => VimCommand::None,
        }
    }

    pub fn from_string(s: &str) -> VimCommand {
        match s {
            "h" => VimCommand::MoveLeft,
            "j" => VimCommand::MoveDown,
            "k" => VimCommand::MoveUp,
            "l" => VimCommand::MoveRight,
            "w" => VimCommand::MoveWordForward,
            "b" => VimCommand::MoveWordBack,
            "e" => VimCommand::MoveWordEnd,
            "0" => VimCommand::MoveLineStart,
            "$" => VimCommand::MoveLineEnd,
            "H" => VimCommand::MoveScreenTop,
            "M" => VimCommand::MoveScreenMiddle,
            "L" => VimCommand::MoveScreenBottom,
            "}" => VimCommand::MoveParagraphForward,
            "{" => VimCommand::MoveParagraphBack,
            "StartSearchBackward" => VimCommand::StartSearchBackward,
            "StartSearchForward" => VimCommand::StartSearchForward,
            "NextMatch" => VimCommand::NextMatch,
            "DeleteChar" => VimCommand::DeleteChar,
            _ => VimCommand::None,
        }
    }
}

impl VimCommand {
    pub fn to_display_string(&self) -> String {
        match self {
            VimCommand::MoveLeft => "h (Move Left)".to_string(),
            VimCommand::MoveDown => "j (Move Down)".to_string(),
            VimCommand::MoveUp => "k (Move Up)".to_string(),
            VimCommand::MoveRight => "l (Move Right)".to_string(),
            VimCommand::MoveWordForward => "w (Word Forward)".to_string(),
            VimCommand::MoveWordBack => "b (Word Back)".to_string(),
            VimCommand::MoveWordEnd => "e (Word End)".to_string(),
            VimCommand::MoveLineStart => "0 (Line Start)".to_string(),
            VimCommand::MoveLineEnd => "$ (Line End)".to_string(),
            VimCommand::MoveScreenTop => "H (Screen Top)".to_string(),
            VimCommand::MoveScreenMiddle => "M (Screen Middle)".to_string(),
            VimCommand::MoveScreenBottom => "L (Screen Bottom)".to_string(),
            VimCommand::MoveParagraphForward => "} (Paragraph Fwd)".to_string(),
            VimCommand::MoveParagraphBack => "{ (Paragraph Back)".to_string(),
            VimCommand::InsertMode => "i (Insert Mode)".to_string(),
            VimCommand::Escape => "Esc".to_string(),
            VimCommand::StartFindNext => "f (Find Next)".to_string(),
            VimCommand::StartFindPrev => "F (Find Prev)".to_string(),
            VimCommand::StartTillNext => "t (Till Next)".to_string(),
            VimCommand::StartTillPrev => "T (Till Prev)".to_string(),
            VimCommand::RepeatFind => "; (Repeat Find)".to_string(),
            VimCommand::RepeatFindReverse => ", (Repeat Reverse)".to_string(),
            VimCommand::StartSearchForward => "/ (Search Fwd)".to_string(),
            VimCommand::StartSearchBackward => "? (Search Back)".to_string(),
            VimCommand::NextMatch => "n (Next Match)".to_string(),
            VimCommand::PrevMatch => "N (Prev Match)".to_string(),
            VimCommand::DeleteChar => "x (Delete Char)".to_string(),
            VimCommand::FindNextChar(c) => format!("f {} (Find '{}')", c, c),
            VimCommand::FindPrevChar(c) => format!("F {} (Find Prev '{}')", c, c),
            VimCommand::TillNextChar(c) => format!("t {} (Till '{}')", c, c),
            VimCommand::TillPrevChar(c) => format!("T {} (Till Prev '{}')", c, c),
            VimCommand::SearchForward(s) => format!("/{} (Search '{}')", s, s),
            VimCommand::SearchBackward(s) => format!("?{} (Search Back '{}')", s, s),
            VimCommand::None => "None".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_movement_mapping() {
        let mut handler = InputHandler::new();
        assert_eq!(handler.map_key(KeyCode::H, false), VimCommand::MoveLeft);
        assert_eq!(handler.map_key(KeyCode::J, false), VimCommand::MoveDown);
        assert_eq!(handler.map_key(KeyCode::K, false), VimCommand::MoveUp);
        assert_eq!(handler.map_key(KeyCode::L, false), VimCommand::MoveRight);
    }
}
